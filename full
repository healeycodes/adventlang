// this is a test file for the base grammar
// it should parse without errors

let set = func(list) {
    let store = {};
    if (type(list) == "list") {
        for (let i = 0; i < list.len; i = i + 1) {
            store[list[i]] = true;
        }
    }
    return {
        "add": func(x) { store[x] = true; },
        "has": func(x) { return store[x] == true }
    }
};
let nums = set([1, 2, 3]);
nums["has"](1);

// core
let a = 1; // golang float64, + - / *
a; // 1
a = 2; // redeclare
if (true) {
    a = 3;
    let new_a = 4;
}
// a is 3, new_a is an error

for (let i = 0; i < 10; i = i + 1) {
    print(i);
}

f = open("./example.txt");
while (f.has_more()) {
    print(f.next_line()); // how does this handle trailing \n
    //     .next_byte()
    //     .all()
}
// f.close()?

let b = "andrew"; // immutable array of bytes, +

let c = {
    "some key": true,
    b: a
};
let key = "b";
c[key];
c[key] = 2;

let d = [c];
d[0];
d.len; // dot for built-in methods/props only

let e = func(x, y) {
    return x + y
};
print(e(1, 3)); // outputs: 3

let nested_func = func() {
    return func() { return }
};
nested_func()();
let one = func() { return 1 };
a.b["2"](3, 4);
let list = [1, 2, (3), one(), a.b["2"](3, 4)];
let list2 = [{ "b": (4) }, { b: true }];

let bool = true != false or false;
let bool2 = true and true;

(func() { return })(2).len;

one = (func() { return 1 })();